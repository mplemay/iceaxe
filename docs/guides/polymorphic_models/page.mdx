# Polymorphic Models

Iceaxe supports polymorphic models through single table inheritance. This allows you to define a base model class that can be loaded as different subclasses based on a discriminator column.

## Basic Usage

To use polymorphic models, inherit from `PolymorphicBase` instead of `TableBase`:

```python
from enum import StrEnum
from iceaxe import PolymorphicBase, Field

class AnimalType(StrEnum):
    DOG = "dog"
    CAT = "cat"
    BIRD = "bird"

class Animal(PolymorphicBase):
    id: int = Field(primary_key=True)
    type: AnimalType = Field(discriminator_type=True) # Mark discriminator column
    name: str
    age: int

class Dog(Animal):
    breed: str | None = None
    bark_volume: int | None = None

class Cat(Animal):
    fur_color: str | None = None
    lives_left: int | None = None

class Bird(Animal):
    wingspan: float | None = None
    can_talk: bool | None = None
```

## How It Works

When you create a polymorphic model hierarchy:

1. Define a base model that inherits from `PolymorphicBase`
2. Mark one column as the discriminator using `discriminator_type=True`
3. Create subclasses that inherit from the base model

When you query the base model, Iceaxe will automatically instantiate the appropriate subclass based on the value in the discriminator column.

## Database Table Structure

Polymorphic models use a single table inheritance pattern. This means all subclasses share the same database table, with columns for all fields from all subclasses. When a field isn't used by a particular subclass, it will be NULL in the database.

For example, the `Animal` model above would create a single table with columns for all fields: `id`, `type`, `name`, `age`, `breed`, `bark_volume`, `fur_color`, `lives_left`, `wingspan`, and `can_talk`.

## Inserting Data

When inserting a polymorphic model, make sure to set the discriminator field to the appropriate value:

```python
# Create instances of different subclasses
dog = Dog(type=AnimalType.DOG, name="Buddy", age=5, breed="Golden Retriever", bark_volume=8)
cat = Cat(type=AnimalType.CAT, name="Whiskers", age=3, fur_color="Tabby", lives_left=9)
bird = Bird(type=AnimalType.BIRD, name="Polly", age=2, wingspan=0.3, can_talk=True)

# Insert them into the database
await conn.insert([dog, cat, bird])
```

## Querying Data

When you query the base model, Iceaxe will automatically return instances of the appropriate subclass:

```python
from iceaxe.queries import select

# Query all animals
animals = await conn.exec(select(Animal))

# animals will contain a mix of Dog, Cat, and Bird instances,
# depending on the 'type' column value for each row

# You can also query specific types
dogs = await conn.exec(select(Animal).where(Animal.type == AnimalType.DOG))
# dogs will contain only Dog instances
```

## Deep Inheritance Hierarchies

Iceaxe supports multi-level inheritance hierarchies. You can create subclasses of subclasses, and Iceaxe will handle the polymorphic loading correctly:

```python
class Dog(Animal):
    type: AnimalType = AnimalType.DOG  # Override the discriminator value
    breed: str | None = None
    size_category: str  # e.g., "small", "medium", "large"

class SmallDog(Dog):
    # Still uses the same "type" discriminator field from Animal
    # But needs its own unique discriminator value
    type: str = "small_dog"  # Custom discriminator value
    
    # Additional fields specific to small dogs
    guard_trained: bool = False
    
class WorkingDog(Dog):
    type: str = "working_dog"
    job_type: str  # e.g., "herding", "search and rescue", "guide dog"
    certification_level: int
```

When querying, Iceaxe will correctly instantiate the most specific subclass based on the discriminator value:

```python
# Will return a mix of all animal types, including specialized dog subclasses
animals = await conn.exec(select(Animal))

# Will return only dogs, including SmallDog and WorkingDog instances
dogs = await conn.exec(select(Dog))

# Will return only SmallDog instances
small_dogs = await conn.exec(select(Animal).where(Animal.type == "small_dog"))
```

## Automatic Type Registration

Iceaxe automatically registers all subclasses of your polymorphic models. By default, the discriminator value is the class name, but you can override this by setting a default value for the discriminator field:

```python
class Cat(Animal):
    type: AnimalType = AnimalType.CAT  # Override the discriminator value
    fur_color: str | None = None
    lives_left: int | None = None
```

## Advanced Usage

### Custom Discriminator Field

You can use any field as the discriminator, not just a type field:

```python
class Content(PolymorphicBase):
    id: int = Field(primary_key=True)
    content_type: str = Field(discriminator_type=True)
    title: str
    created_at: datetime

class TextContent(Content):
    content_type: str = "text"
    text: str

class ImageContent(Content):
    content_type: str = "image"
    image_url: str
    width: int
    height: int
```

### Working with Nullable Fields

Since all subclass-specific fields are stored in the same table, make sure that fields unique to each subclass are nullable or have default values:

```python
class Dog(Animal):
    breed: str | None = None  # Nullable because cats and birds won't have a breed
    bark_volume: int = 0  # Default value
```

This is particularly important when adding new fields to existing polymorphic models through migrations.

### Best Practices

1. **Keep your discriminator values consistent**: Use enums or string constants to ensure discriminator values are consistent across your codebase.

2. **Make subclass-specific fields nullable**: Since all fields share the same table, fields specific to one subclass should be nullable to accommodate other subclass instances.

3. **Consider performance implications**: Single table inheritance can lead to tables with many nullable columns. For very complex hierarchies with many subclasses, consider if another approach might be more efficient.

4. **Be careful with migrations**: When adding new fields to subclasses or new subclasses to a hierarchy, consider existing data and whether null constraints need to be adjusted.

5. **Use descriptive discriminator values**: The discriminator value should clearly identify the subclass type, especially if you're not using the class name as the default value.

6. **Validate object creation**: Consider adding validation to ensure subclass-specific required fields are set when creating instances.

### Migration Considerations

When adding new fields to polymorphic subclasses, you'll need to add those columns to the base table. Make sure to make these fields nullable or provide default values to handle existing data.

When adding new subclasses to an existing hierarchy, ensure the discriminator value is unique and not already used by existing data.

```python
# Migration to add a new field to a subclass
async def migrate(conn):
    # Add a new column to the animal table for a new Dog attribute
    await conn.execute("""
        ALTER TABLE animal
        ADD COLUMN training_level INT
    """)
``` 